from pydantic import BaseModel, Field, validator
from typing import Literal, Optional
from datetime import datetime
import re

# Regex for basic IP address validation (IPv4)
# For more robust validation, consider a dedicated library if needed.
IP_ADDRESS_REGEX = r"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"

class Device(BaseModel):
    id: str = Field(..., description="Unique identifier for the device")
    tenantId: str = Field(..., description="Identifier for the tenant this device belongs to")
    name: str = Field(..., description="Display name of the device")
    type: str = Field(..., description="Type of the device (e.g., router, switch, firewall)")
    ipAddress: str = Field(..., description="IP address of the device")
    platform: str = Field(..., description="Platform or OS of the device (e.g., Cisco IOS, Junos, Linux)")
    status: Literal['online', 'offline', 'maintenance'] = Field(..., description="Current status of the device")
    createdAt: datetime = Field(default_factory=datetime.utcnow, description="Timestamp of device creation")
    updatedAt: datetime = Field(default_factory=datetime.utcnow, description="Timestamp of last device update")
    
    # Optional fields that might be in the full device schema based on project docs or common needs
    siteId: Optional[str] = Field(None, description="Identifier for the site this device belongs to")
    # credentials: Optional[dict] = Field(None, description="Credentials for accessing the device (store securely!)")
    # hardware_specs: Optional[dict] = Field(None, description="Hardware specifications")
    # monitoring_parameters: Optional[dict] = Field(None, description="Specific monitoring parameters for this device")
    # tags: Optional[list[str]] = Field(default_factory=list, description="Tags for grouping/filtering")

    @validator('ipAddress')
    def validate_ip_address(cls, v):
        if not re.match(IP_ADDRESS_REGEX, v):
            raise ValueError('Invalid IP address format')
        return v

    @validator('createdAt', 'updatedAt', pre=True)
    def parse_datetime_str(cls, v):
        if isinstance(v, str):
            try:
                return datetime.fromisoformat(v.replace('Z', '+00:00'))
            except ValueError:
                raise ValueError("Invalid datetime format, expected ISO format string")
        return v
    
    class Config:
        # This allows Pydantic to populate the model from an ORM object or dict with extra fields
        orm_mode = True 
        # Example for Elasticsearch: usually, ES documents are dicts, so orm_mode might not be strictly needed
        # if you are directly converting dicts from ES to Pydantic models.
        # However, it's good practice if you might have other data sources.

        # If your Elasticsearch documents use `_id` for the document ID, you might want to alias it.
        # For now, we assume 'id' is a regular field in your ES document.
        # fields = {'_id': 'id'} # If ES uses _id and you want your model to have `id`.

# Example for creating a device (for POST requests, ID might be generated by ES or service)
class DeviceCreate(BaseModel):
    tenantId: str
    name: str
    type: str
    ipAddress: str
    platform: str
    status: Literal['online', 'offline', 'maintenance'] = 'offline' # Default status on creation
    siteId: Optional[str] = None

    @validator('ipAddress')
    def validate_ip_address(cls, v):
        if not re.match(IP_ADDRESS_REGEX, v):
            raise ValueError('Invalid IP address format')
        return v

# Example for updating a device (all fields optional for PATCH-like behavior)
class DeviceUpdate(BaseModel):
    name: Optional[str] = None
    type: Optional[str] = None
    ipAddress: Optional[str] = None
    platform: Optional[str] = None
    status: Optional[Literal['online', 'offline', 'maintenance']] = None
    siteId: Optional[str] = None

    @validator('ipAddress', pre=True, always=True)
    def validate_ip_address(cls, v):
        if v is not None and not re.match(IP_ADDRESS_REGEX, v):
            raise ValueError('Invalid IP address format')
        return v 